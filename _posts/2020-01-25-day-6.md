---
layout: post
title: Day6
hide_title: False
excerpt: Boost Camp AI Tech - DAY 6
toc: true
toc_sticky: true
# toc_label: Category
feature-img: assets/img/feature-img/story.jpeg
author: Jay
tags: [Boost camp, AI tech, Day6]
---

# Day 6

#### 진행 사항
  - [x] Numerical Python - numpy
      - [x] ndarray
      - [x] Handling shape
      - [x] indexing & slicing
      - [x] creation function
      - [x] operation functions
      - [x] array operations
      - [x] comparisons
      - [x] boolean & fancy index
      - [x] numpy data i/o
  - [x] Mathematics for Artificial Intelligence
    - [x] 1강: 벡터가 뭔가요?
    - [x] 2강: 행렬은 뭔가요?
  - [x] 피어세션 
  - [x] 개인학습


## 학습 내용
---
지난 1주차에 파이썬을 사용하기 위한 기초를 다졌다면, 이번주차부터는 AI에 필요한 수학적 지식과 더불어 이를 코드로 구현할 수 있는 방법에 대해 배우게 됩니다. 2주차의 첫날인 오늘은 파이썬의 과학 처리 패키지인 numpy의 사용법과 AI에 필요한 수학의 가장 기초라고 할 수 있는 벡터와 행렬에 대해 학습하였습니다.   

다음은 강의 내용을 정리한 것입니다.   

<br> 

## Numerical Python - numpy
---
numpy는 c언어로 구현된 파이썬의 과학 처리 패키지입니다. 고성능의 수치계산을 위해 제작되었으며 Numerical Python의 줄임말입니다. 기존 matlab의 역할을 대체하고 있습니다. 때문에 데이터 분석 시 사용되는 라이브러리인 pandas와 matplotlib의 기반으로 사용되기도 합니다.   
특히 matrix와 vecto와 같은 array 연산의 사실상 표준이기도 합니다. numpy에서 제공하는 array는 일반 list에 비해 빠르고 메모리 효율적입니다. 또한, c언어를 기반으로 만들어졌기 때문에 c, c++, 포트란 등의 언어와도 통합 가능합니다.   

### ndarray
~~~python
import numpy as np
~~~
일반적으로 numpy는 np라는 alias(별칭)을 이용해서 호출합니다.   

numpy는 np.array 함수를 사용하여 ndarray라는 배열을 생성하는데, 이 array는 c의 array를 사용하여 배열을 생성하기 때문에 c의 array 성격을 가지고 있습니다. 즉, dynamic typing이 지원되지 않기 때문에 하나의 array에는 하나의 데이터 타입만 가능합니다.   
~~~python
test_array = np.array([1,2,3,4], float)
print(test_array)
>>> array([1.,2.,3.,4.])
type(test_array[3])
>>> numpy.float64
~~~

#### array creation
array와 list에서 속도에 차이를 가지는 이유는 메모리 할당에 있습니다. list의 경우 메모리에 이미 할당되어 있는 값을 list에 연결시켜주는 것이기 때문에 메모리의 주소값을 가지고 있습니다. 때문에 다른 list여도 같은 값을 가진다면 같은 주소를 가지고 있습니다. 이에 반해 array의 경우에는 필요한 만큼의 메모리 블록을 할당하여 값들을 메모리에 각각 할당시킵니다. 때문에 각각의 array들은 각각의 메모리 주소를 가지고 있게 됩니다.   

~~~python
a = [1,2,3,4,5]
b = [5,4,3,2,1]

 #메모리 비교
a[0] is b[0] >>> True #a[0]의 주소값과 b[-1]의 주소값이 같으므로 True

a = np.array(a)
b = np.array(b)
a[0] is b[0] >>> False #array a와 b가 각각 다른 메모리가 값이 할당되어 있으므로 값은 같지만 메모리 주소는 다르기 때문에 False
~~~

**>>shape & dtype**    
shape은 nparray의 차원(dimension) 구성을 반환하는 함수이며, dtype은 nparray의 데이터 타입을 반환하는 함수입니다.   
~~~python
test_array = np.array([1,2,3,"4"], float) #string type이 입력되어도 데이터 타입을 float로 통일

print(test_array)
>>> array([1.,2.,3.,4.])
print(type(test_array[3]))  #string으로 입력되었지만 float으로 형변환
>>> numpy.float64
print(test_array.dtype)  #array 전체의 데이터 타입을 반환
>>> dtype('float64')
print(test_array.shape)  #array의 shape을 반환(튜플 형태), 1차원일 경우 튜플 입력에 의해 콤마로 표현
>>> (4,)
~~~

array의 shape은 Rank에 따라 인자의 개수가 차이가 나게 됩니다. 여기서 Rank는 차원으로 이해할 수도 있습니다.   
Rank 0 : scalar   
Rank 1 : vector
Rank 2 : matrix   
Rank 3 : 3-tensor   (3rd order tensor)
Rank n : n-tensor   (n-th order tensor)
~~~python
vector = np.array([1,2], int)
vector.shape >>> (2,)
matrix = np.array([[1,2],[2,3],[3,4]], int)
matrix.shape >>> (3,2)
3_tensor = np.array([[[1,2],[2,3],[3,4]],
                     [[2,3],[3,4],[4,5]]], int)
3_tensor.shpae >>> (2,3,2)
~~~
Rank에 따라 튜플로 표시되는 shape의 인자 개수가 달라지며, 앞 랭크의 인자가 뒤로 밀리는 현상을 보이면서 표현됩니다.   


dtype은 np.array(어래이, dtype='타입')으로 표시되며 데이터 타입에 의해 각 인자가 차지하는 메모리의 크기가 결정됩니다. 이는 np.array().nbytes를 통해 얻을 수 있습니다.   

### Handling shape
#### reshape
Array의 인자 개수를 유지하면서 shape을 변경하도록 하는 함수입니다. shape이 튜플 형태로 표시 되기 때문에 reshape의 입력값 역시 튜플 형식으로 입력됩니다.   
~~~python
test_matrix = [[1,2,3],[4,5,6]]
np.array(test_matrix).shape >>> (2,3)
np.array(test_matrix).reshape(6,) >>> array([1,2,3,4,5,6])
np.array(test_matrix).reshape(6,).shape >>> (6,)

np.array(test_matrix).reshape(3,-1).shape >>> (3,2)  #-1을 넣으면 알아서 계산해서 채워줌
np.array(test_matrix).reshape(-1,2).shape >>> (3,2)
~~~

#### flatten
flatten은 다차원의 array를 1차원 array로 변환 시켜주는 함수입니다.   
~~~python
test_matrix = [[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]]
np.array(test_matrix).shape >>> (2,2,3)
np.array(test_matrix).flatten() >>> array([1,2,3,4,5,6,7,8,9,10,11,12])
~~~

### indexing & slicing
#### indexing
array[0][0] 표현과 array[0,0] 표현 모두 가능   
~~~python
a = np.array([[1, 2, 3], [4.5, 5, 6]], int)
print(a) >>> array([[1,2,3],[4,5,6]])
print(a[0,0])  >>> 1  # Two dimensional array representation #1
print(a[0][0]) >>> 1  # Two dimensional array representation #2

a[0,0] = 12  # Matrix 0,0 에 12 할당
print(a) >>> array([[12,2,3],[4,5,6]])
a[0][0] = 5  # Matrix 0,0 에 12 할당
print(a) >>> array([[5,2,3],[4,5,6]])
~~~

#### slicing
list와 달리 행과 열 부분을 나눠서 slicing이 가능합니다. matrix에서 부분 집합을 추출할 때 주로 쓰입니다.   
~~~python
a = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]], int)
a[:,2:]  # 전체 Row의 2열 이상
a[1,1:3]  # 1 Row의 1열 ~ 2열
a[1:3]  # 1 Row ~ 2Row의 전체
~~~

### creation function
#### arange
arange는 array의 범위를 지정하여 값의 list를 생성하는 명령어 입니다.   
~~~python
np.arange(5)
>>> array([0,1,2,3,4])
np.arange(0, 5, 0.5)  #(시작, 끝, step)  step은 floating point도 표시 가능
>>> array([0.,0.5,1.,1.5,2.,2.5,3.,3.5,4.,4.5])
np.arrange(6).reshape(2,3)
>>> array([[0,1,2],[3,4,5]])
~~~

#### zeros, ones and empty
0으로 가득찬 ndarray를 생성하는 zeros, 1로 가득찬 ndarray를 생성하는 ones, 그리고 shape만 주고 비어있는 ndarray를 생성하는 empty 함수가 있습니다. empty는 생성 시 비어있기 때문에 memory initialization이 되지 않습니다.  
모두 (shape, dtype, order)를 입력받아 생성합니다.    
~~~python
np.zeros(shape=(6,), dtype = np.int8)
>>> array([0,0,0,0,0,0], dtype=int8)
np.zeros((2,3))
>>> array([[0,0,0],[0,0,0]])

np.ones(shape=(6,), dtype = np.int8)
>>> array([1,1,1,1,1,1], dtype=int8)
np.ones((2,3))

np.empty(shape=(6,0), dtype = np.int8)
>>> array([0,0,1,-2,2,3], dtype=int8)  #할당하고자 하는 memory 주소만 존재하고 initialization이 되지 않아 기존에 주소에 저장된 값 표시
np.empty((2,3))
>>> #역시 initialization이 되지 않아 할당하고자 하는 주소에 저장되어 있던 값 표시
~~~

**something_like**
기존의 ndarray의 shape 크기 만큼 1, 0 또는 empty array를 만들도록 합니다. (np.zeros_like(어래이), np.ones_like(어래이), np.empty_like(어래이))

#### identity
단위 행렬을 생성하는 함수를 의미합니다. 역시 (number of rows, dtype, order)를 사용합니다.   
~~~python
np.identity(n=3, dtype=np.int8)
>>> array([[1,0,0],[0,1,0],[0,0,1]], dtype=int8)
np.identity(2)
>>> array([[1,0],[0,1]])
~~~

**eye & diag**
eye는 대각선이 1인 행렬을 생성하는 함수로 k값으로 시작 index의 변경이 가능합니다. (row, column, k, dtype)을 사용합니다.     
~~~python
np.eye(2,3,k=1)
>>> array([[0,1,0],[0,0,1]])
~~~

diag는 대각 행렬의 값을 추출하는 함수입니다. k값으로 시작 index의 변경이 가능합니다. (matrix, k)   
~~~python
matrix = np.arange(9).reshape(3,3)
np.diag(matrix)
>>> array([0,4,8])
np.diag(matrix, k=1)
>>>array([1,5])
~~~



<br>

## 피어세션
---
further question   
코드 리뷰   
퀴즈 리뷰   
수업 중 어려웠던 부분   


수업 중 어려웠던 부분 + further quesiton에 대해서 

<br>

## 개인 학습
---
