---
layout: post
title: Day5
hide_title: False
excerpt: Boost Camp AI Tech - DAY 5
toc: true
toc_sticky: true
# toc_label: Category
feature-img: assets/img/feature-img/story.jpeg
author: Jay
tags: [Boost camp, AI tech, Day4]
---

# Day 5

### 진행 사항
  - [x] 파이썬으로 데이터 다루기
      - [x] Exception/File/Log Handling
      - [x] Data Handling
  - [x] 마스터 클래스
  - [x] 피어세션
  - [x] 개인 학습


## 학습 내용
---


다음은 강의 내용을 정리한 것입니다.

_   

## 파이썬으로 데이터 다루기
---
### Exception/File/Log Handling
#### Exception Handling
**>>Exception**   
예외(exception)는 프로그램을 사용할 때 흔히 일어나는 일로 크게 1) 예상 가능한 예외와 2) 예상 불가능한 예외로 나눌 수 있습니다.    
1) 예상 가능한 예외의 경우, 사용자의 잘못된 입력이나 없는 파일에 대한 호출 등 발생 여부를 사전에 인지할 수 있는 경우로 개발자가 반드시 명시적으로 정의 해야합니다.
2) 예상 불가능한 예외는 리스트의 범위를 넘어가는 값 호출이나 정수를 0으로 나누는 등 인터프리터 과정에서 발생하는 예외나 개발자의 실수로 인해 발생하는 경우로 수행 불가 시 인터프리터가 자동으로 호출됩니다.  

예외가 발생할 경우 후속 조치와 같은 대처가 필요하기 때문에 exception handling이 필요합니다.   

**>>Exception Handling**     
파이썬에서 예외 처리를 위한 try ~ except 문법이 있습니다.   
~~~python
try:
    예외 발생 가능 코드
except <Exception Type>:
    예외 발생 시 대응하는 코드
~~~   


  |  Exception 이름   |                 내용                 |
  | :---------------: | :----------------------------------: |
  |    IndexError     |    List의 Index 범위를 넘어갈 때     |
  |     NameError     |   존재하지 않은 변수를 호출 할 때    |
  | ZeroDivisionError |         0으로 숫자를 나눌 때         |
  |    ValueError     | 변환할 수 없는 문자/숫자를 변환할 때 |
  | FileNotFoundError |    존재하지 않는 파일을 호출할 때    |
  |     Exception     |   Excetion Type를 지정하지 않을 때   |

예시) 0으로 숫자를 나눌 때 예외처리 하기   
~~~python
for i in range(10):
    try:
        print(10/i)
    except ZeroDivisionError:
        print("Not divided by 0")
~~~   

예외 정보를 표시할 때는 except ZeroDivisionError as e: 로 넣어서 print(e)를 통해 표시합니다.   

try except에 추가로 else, finally, raise, assert 구문을 사용할 수 있습니다.   
else는 예외가 발생하지 않을 때 동작하는 코드를 입력합니다.   
finally는 예외 발생 여부와 상관없이 실행되는 코드를 입력합니다.   
raise는 필요에 따라 강제로 Exception을 발생시킵니다.// raise <Exception Type>(예외정보)   
assert는 특정조건에 만족하지 않을 경우 예외를 발생시킵니다.// assert 예외조건   

예시)   
~~~python
<try ~ except ~ else>
for i in range(10):
    try:
        print(10/i)
    except ZeroDivisionError:
        print("Not divided by 0")
    else:
        print(10/i)

<try ~ except ~ finally>
try:
    for i in range(1,10):
        result = 10 / i
        print(result)
except ZeroDivisionError:
    print("Not divided by 0")
finally:
    print("종료되었습니다.")

<raise>
while True:
    value= input("변환할정수값을입력해주세요")
    for digit in value:
        if digit not in "0123456789":
            raise ValueError("숫자값을입력하지않으셨습니다")
    print("정수값으로변환된숫자-", int(value))

<assert>
def get_binary_nmubmer(decimal_number):
    assert isinstance(decimal_number, int)
    return bin(decimal_number)
print(get_binary_nmubmer(10))
~~~

#### File Handling
기본적인 파일의 종류로는 binary 파일과 text 파일 두 가지로 나뉩니다.   

Binary 파일은 컴퓨터만 이해할 수 있는 형태인 이진(법)형식으로 저장된 파일을 의미합니다.   
Text 파일은 인간도 이해할 수 있는 형태인 문자열 형식으로 저장된 파일을 의미합니다.   

컴퓨터는 text 파일을 처리하기 위해 이를 binary 파일로 변환시킵니다. 때문에 모든 text 파일은 실제로 binary 파일로 되어있지만 ASCII/Unicode 문자열 집합으로 저장되어 사람이 읽을 수 있습니다.    

**Python File I/O**   
파이썬은 파일 처리를 위해 "open" 키워드를 사용합니다.
~~~python
f = open("<파일이름>", "접근 모드")
f.close()
~~~   
파일은 기본적으로 프로그램과 같은 디렉토리에 있다는 기준으로 작성됩니다. 또한, 접근 모드로는 읽기(r), 쓰기(w), 추가(a) 모드가 존재하는데, 추가모드는 파일의 마지막에 새로운 내용을 추가시킬 때 사용합니다.   

먼저 File Read 입니다.   
~~~python
f= open("i_have_a_dream.txt","r")
contents= f.read()
print(contents)
f.close()

with open("i_have_a_dream.txt", "r") as my_file:
    contents= my_file.read()
    print(type(contents), contents)
~~~   

with 구문으로도 표현할 수 있습니다.   

wirte과 append 모두 데이터를 입력하는 것으로 encoding 방식을 정해주어야 합니다. 대게 utf8을 사용합니다.   
~~~python
f= open("count_log.txt", 'w', encoding="utf8") 
for i in range(1, 11):
    data= "%d번째줄입니다.\n" % 
    if.write(data)
f.close()

with open("count_log.txt", 'a', encoding="utf8") as f:
for i in range(1, 11):
    data= "%d번째줄입니다.\n" % i
    f.write(data)
~~~

**디렉토리 다루기**   
os 모듈을 사용하여 directory를 다룰 수 있습니다.   
~~~python
<디렉토리 생성>
import os
os.mkdir("log")

<디렉토리가 있는지 확인>
if not os.path.isdir("log"):
    os.mkdir("log")
~~~ 
os.path 내의 함수를 활용하여 디렉토리 관리 가능합니다.(ex. os.path.isdir(), os.path.shutil()  등)   

최근에는 pathlib 모듈을 사용하여 path를 객체로 다룹니다.  
~~~python
>>>importpathlib
>>>
>>>cwd=pathlib.Path.cwd()
>>>cwd
WindowsPath('D:/workspace')
>>>cwd.parent
WindowsPath('D:/')
>>>list(cwd.parents)
[WindowsPath('D:/')]
>>>list(cwd.glob("*"))
[WindowsPath('D:/workspace/ai-pnpp'),WindowsPath('D:/workspace/cs50_auto_grader'),WindowsPath('D:/workspace/data-academy'),WindowsPath('D:/workspace/DSME-AI-Smart-Yard'),WindowsPath('D:/workspace/introduction_to_python_TEAMLAB_MOOC'),
~~~

**Log 파일 생성하기**   
디렉토리가 있는지, 파일이 있는지 확인 후 로그 생성   
~~~python
import os
if not os.path.isdir("log"):
    os.mkdir("log")
if not os.path.exists("log/count_log.txt"):
    f= open("log/count_log.txt", 'w', encoding="utf8")
    f.write("기록이시작됩니다\n")f.close()

with open("log/count_log.txt", 'a', encoding="utf8") as f:
    import random, datetime
    for i in range(1, 11):
        stamp= str(datetime.datetime.now())
        value= random.random() * 1000000
        log_line= stamp+ "\t" + str(value) +"값이생성되었습니다" + "\n"
        f.write(log_line)
~~~

**Pickle**   
피클은 파이썬의 객체를 영속화(persistence)하는 built-in 객체입니다. 객체는 일반적으로 메모리에 위치하는데, 영속화를 시켜주기 위해 데이터나 object 등 실행중 정보를 파일로 저장하고, 추후에 불러와서 사용을 할 수 있도록 합니다. 


#### Log Handling
프로그램이 실행되는 동안 일어나는 정보를 기록으로 남기는 행위를 로그를 남긴다고 합니다. 유저의 접근, 프로그램의 Exception, 특정 함수의 사용 등 다양한 이유로 로그를 남기고 있으며, 로그를 남기는 방법으로는 Console 화면에 출력하거나 파일로 남기거나 DB에 남기는 방법 등이 있습니다.   
로그는 실행시점에서 남기는 것과 개발 시점에서 남기는 것으로 크게 두 가지로 나뉩니다.



**Logging Level**   

  |  Level   |                                       개요                                        | 예시                                                                          |
  | :------: | :-------------------------------------------------------------------------------: | :---------------------------------------------------------------------------- |
  |  debug   |                  개발 시 처리 기록을 남겨야하는 로그 정보를 남김                  | 함수 호출, 변수 변경 등                                                       |
  |   info   |                        처리가 진행되는 동안의 정보를 알림                         | 서버 시작 및 종료, 사용자 접속 기록 등                                        |
  | warning  | 사용자가 잘못 입력한 정보나 처리는 가능하지만 의도치 않은 정보가 들어왔을 때 알림 | str입력을 기대했으나 int가 입력되었을 때 str casting으로 처리 가능하지만 알림 |
  |  error   |         잘못된 처리로 인해 에러가 났으나 프로그램은 동작할 수 있음을 알림         | 파일에 기록해야하는데 파일이 없음                                             |
  | ciritcal |      잘못된 처리로 데이터 손실이나 더 이상 프로그램이 동작할 수 없음을 알림       | 잘못된 접근으로 해당 파일이 삭제 혹은 강제 종료                            료  |

기본적인 레벨 값은 warning 이상으로 설정되어 있습니다.  

#### 프로그램 실행 설정
예

**>>configparser**   
나   

**>>argparser**   
나   

#### Logging 적용하기
ㅇ

## 피어 세션
---


## 개인 학습
---
오늘은 어제 진행했던 morsecode에서 가졌던 궁금증에 대해 알아보았습니다.   
False에 대한 표현으로 아래 예시들처럼 여러가지 표현으로 작성할 수 있습니다. 
~~~python
~ == False
~ is False
~ is not True
not ~
~~~
하지만 morsecode에서 모스부호의 입력을 받을 때 이 값이 key:알파벳, value:모스부호 로 이루어진 morse_code_dict의 value값에 있는지 확인하는 과정에서 그 값이 다르게 리턴되었습니다.